<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="page.title">Account Termination API Optimization Case Study | Eunmi Kong</title>
    <link rel="icon" type="image/png" href="IMG_1926.png">
    <link rel="apple-touch-icon" href="IMG_1926.png">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="style-sub.css">

</head>
<body>
    <div class="page" role="document">
        <div class="case-study-container">
            <a href="index.html#experience" class="back-link" data-i18n="page.backLink">
                ← Back to Portfolio
            </a>

            <div class="case-study-header">
                <h1 class="case-study-title" data-i18n="page.mainTitle">Account Termination API Optimization</h1>
            </div>

            <div class="overview-box">
                <p data-i18n="page.overview">
                    This page describes how I reduced database CPU spikes and improved API responsiveness by refactoring a heavy account termination API, minimizing transactional scope, and offloading non-critical operations to batch processing.
                </p>
            </div>

            <div class="content-section">
                <h2 data-i18n="page.background.title">Background</h2>
                <ul>
                    <li data-i18n="page.background.item1"> Multiple telecom partners (KT, SKT, LG) shared a single database server</li>
                    <li data-i18n="page.background.item2"> During peak periods, overlapping account termination requests caused:
                        <ul>
                            <li data-i18n="page.background.item2_1"> sudden traffic surges</li>
                            <li data-i18n="page.background.item2_2"> database CPU usage to spike up to ~90%</li>
                        </ul>
                    </li>
                    <li data-i18n="page.background.item3"> Issue occurred around 02:02–02:15 AM</li>
                </ul>
            </div>

            <div class="content-section">
                <h2 data-i18n="page.problem.title">Problem</h2>
                <ul>
                    <li data-i18n="page.problem.item1"> The account termination API executed multiple heavy database operations synchronously:</li>
                    <ul>
                        <li data-i18n="page.problem.item1_1"> retrieve, delete, and backup</li>
                    </ul>
                    <li data-i18n="page.problem.item2">All logic was wrapped in a single @Transactional boundary</li>
                    <li data-i18n="page.problem.item3">Concurrent requests from multiple partners caused:</li>
                    <ul>
                        <li data-i18n="page.problem.item3_1">long transaction durations</li>
                        <li data-i18n="page.problem.item3_2">high DB CPU utilization</li>
                        <li data-i18n="page.problem.item3_3">increased risk of service instability</li>
                    </ul>
                </ul>
            </div>

            <div class="content-section">
                <h2 data-i18n="page.analysis.title">Analysis</h2>
                <ul>
                    <li data-i18n="page.analysis.item1"> Identified that only a small subset of logic required immediate consistency:
                        <ul>
                            <li data-i18n="page.analysis.item1_1"> preventing further user activity after termination</li>
                        </ul>
                    </li>
                    <li data-i18n="page.analysis.item2"> Backup, archival, and data migration tasks:
                        <ul>
                            <li data-i18n="page.analysis.item2_1"> were not user-critical</li>
                            <li data-i18n="page.analysis.item2_2"> did not need to run synchronously</li>
                        </ul>
                    </li>
                    <li data-i18n="page.analysis.item3"> Concluded that transaction scope was overly broad and could be safely reduced</li>
                </ul>
            </div>

             <div class="content-section">
                <h2 data-i18n="page.solution.title">Solution</h2>
                <h3 data-i18n="page.solution.section1.title">1. API Lightweight Refactoring</h3>
                <ul>
                    <li data-i18n="page.solution.section1.item1"> Kept only essential logic in the synchronous API:
                        <ul>
                            <li data-i18n="page.solution.section1.item1_1"> updated user status (status = -1) to immediately block usage</li>
                            <li data-i18n="page.solution.section1.item1_2"> performed necessary validations</li>
                        </ul>
                    </li>
                    <li data-i18n="page.solution.section1.item2"> Removed heavy operations from the transaction:
                        <ul>
                            <li data-i18n="page.solution.section1.item2_1"> data migration</li>
                            <li data-i18n="page.solution.section1.item2_2"> backup-related processing</li>
                        </ul>
                    </li>
                </ul>

                <h3 data-i18n="page.solution.section2.title">2. Batch-based Post Processing</h3>
                <ul>
                    <li data-i18n="page.solution.section2.item1"> Introduced a dedicated batch job to handle termination-related cleanup:
                        <ul>
                            <li data-i18n="page.solution.section2.item1_1"> executed during off-peak hours (04:00–05:00 AM)</li>
                            <li data-i18n="page.solution.section2.item1_2"> performed necessary validations</li>
                        </ul>
                    </li>
                    <li data-i18n="page.solution.section2.item2"> Batch processing strategy:
                        <ul>
                            <li data-i18n="page.solution.section2.item2_1"> processed only users with status = -1</li>
                            <li data-i18n="page.solution.section2.item2_2"> added safeguards to avoid infinite retries on problematic records</li>
                            <li data-i18n="page.solution.section2.item2_3"> ensured detailed logging for traceability and recovery</li>
                        </ul>
                    </li>
                </ul>
            </div>

             <div class="content-section">
                <h2 data-i18n="page.result.title">Result</h2>
                <h3 data-i18n="page.result.section1.title">Performance Improvement (Pinpoint)</h3>
                <ul>
                    <li data-i18n="page.result.section1.item1"> Before: API response time ~1250ms </li>
                    <li data-i18n="page.result.section1.item2"> After: API response time ~150ms</li>
                    <li data-i18n="page.result.section1.item3"> Transaction duration significantly reduced</li>
                </ul>

                <h3 data-i18n="page.result.section2.title">System Impact</h3>
                <ul>
                    <li data-i18n="page.result.section2.item1"> Reduced DB CPU spikes during peak termination periods</li>
                    <li data-i18n="page.result.section2.item2"> Improved overall API stability under concurrent traffic</li>
                    <li data-i18n="page.result.section2.item3"> Lowered risk of lock contention on shared database resources</li>
                    <li data-i18n="page.result.section2.item4"> Established a scalable pattern for handling non-critical heavy operations</li>
                </ul>
            </div>

            <div style="margin-top: 4rem; padding-top: 2rem; border-top: 2px solid #e2e8f0;">
                <a href="index.html#experience" class="back-link" data-i18n="page.backLink">
                    ← Back to Portfolio
                </a>
            </div>
        </div>
    </div>

    <script>
        // Page-local translations
        const pageTranslations = {
            en: {
                page: {
                    title: "Account Termination API Optimization Case Study | Eunmi Kong",
                    backLink: "← Back to Portfolio",
                    mainTitle: "Account Termination API Optimization",
                    overview: "This page describes how I reduced database CPU spikes and improved API responsiveness by refactoring a heavy account termination API, minimizing transactional scope, and offloading non-critical operations to batch processing.",
                    background: {
                        title: "Background",
                        item1: "Multiple telecom partners (KT, SKT, LG) shared a single database server",
                        item2: "During peak periods, overlapping account termination requests caused:",
                        item2_1: "sudden traffic surges",
                        item2_2: "database CPU usage to spike up to ~90%",
                        item3: "Issue occurred around 02:02–02:15 AM"
                    },
                    problem: {
                        title: "Problem",
                        item1: "The account termination API executed multiple heavy database operations synchronously:",
                        item1_1: "retrieve, delete, and backup",
                        item2: "All logic was wrapped in a single @Transactional boundary",
                        item3: "Concurrent requests from multiple partners caused:",
                        item3_1: "long transaction durations",
                        item3_2: "high DB CPU utilization",
                        item3_3: "increased risk of service instability"
                    },
                    analysis: {
                        title: "Analysis",
                        item1: "Identified that only a small subset of logic required immediate consistency:",
                        item1_1: "preventing further user activity after termination",
                        item2: "Backup, archival, and data migration tasks:",
                        item2_1: "were not user-critical",
                        item2_2: "did not need to run synchronously",
                        item3: "Concluded that transaction scope was overly broad and could be safely reduced"
                    },
                    solution: {
                        title: "Solution",
                        section1: {
                            title: "1. API Lightweight Refactoring",
                            item1: "Kept only essential logic in the synchronous API:",
                            item1_1: "updated user status (status = -1) to immediately block usage",
                            item1_2: "performed necessary validations",
                            item2: "Removed heavy operations from the transaction:",
                            item2_1: "data migration",
                            item2_2: "backup-related processing"
                        },
                        section2: {
                            title: "2. Batch-based Post Processing",
                            item1: "Introduced a dedicated batch job to handle termination-related cleanup:",
                            item1_1: "executed during off-peak hours (04:00–05:00 AM)",
                            item1_2: "performed necessary validations",
                            item2: "Batch processing strategy:",
                            item2_1: "processed only users with status = -1",
                            item2_2: "added safeguards to avoid infinite retries on problematic records",
                            item2_3: "ensured detailed logging for traceability and recovery"
                        }
                    },
                    result: {
                        title: "Result",
                        section1: {
                            title: "Performance Improvement (Pinpoint)",
                            item1: "Before: API response time ~1250ms",
                            item2: "After: API response time ~150ms",
                            item3: "Transaction duration significantly reduced"
                        },
                        section2: {
                            title: "System Impact",
                            item1: "Reduced DB CPU spikes during peak termination periods",
                            item2: "Improved overall API stability under concurrent traffic",
                            item3: "Lowered risk of lock contention on shared database resources",
                            item4: "Established a scalable pattern for handling non-critical heavy operations"
                        }
                    }
                }
            },
            ko: {
                page: {
                    title: "계정 탈퇴 API 최적화 사례 연구 | 공은미",
                    backLink: "← 포트폴리오로 돌아가기",
                    mainTitle: "계정 탈퇴 API 최적화",
                    overview: "이 페이지는 무거운 계정 탈퇴 API를 리팩토링하고, 트랜잭션 범위를 최소화하며, 비필수 작업을 배치 처리로 분리하여 데이터베이스 CPU 스파이크를 줄이고 API 응답성을 개선한 방법을 설명합니다.",
                    background: {
                        title: "배경",
                        item1: "여러 통신사 파트너(KT, SKT, LG)가 단일 데이터베이스 서버를 공유",
                        item2: "피크 시간대에 중복된 계정 탈퇴 요청으로 인해:",
                        item2_1: "급격한 트래픽 증가 발생",
                        item2_2: "데이터베이스 CPU 사용률이 최대 ~90%까지 급증",
                        item3: "문제는 새벽 02:02–02:15 사이에 발생"
                    },
                    problem: {
                        title: "문제점",
                        item1: "계정 탈퇴 API가 여러 무거운 데이터베이스 작업을 동기적으로 실행:",
                        item1_1: "조회, 삭제, 백업",
                        item2: "모든 로직이 단일 @Transactional 경계로 래핑됨",
                        item3: "여러 파트너의 동시 요청으로 인해:",
                        item3_1: "긴 트랜잭션 지속 시간",
                        item3_2: "높은 DB CPU 사용률",
                        item3_3: "서비스 불안정성 위험 증가"
                    },
                    analysis: {
                        title: "분석",
                        item1: "즉각적인 일관성이 필요한 로직은 일부에 불과함을 확인:",
                        item1_1: "탈퇴 후 추가 사용자 활동 방지",
                        item2: "백업, 아카이빙, 데이터 마이그레이션 작업:",
                        item2_1: "사용자에게 중요하지 않음",
                        item2_2: "동기적으로 실행할 필요 없음",
                        item3: "트랜잭션 범위가 지나치게 넓으며 안전하게 축소 가능하다고 결론"
                    },
                    solution: {
                        title: "해결방안",
                        section1: {
                            title: "1. API 경량화 리팩토링",
                            item1: "동기 API에 필수 로직만 유지:",
                            item1_1: "사용자 상태 업데이트(status = -1)로 즉시 사용 차단",
                            item1_2: "필수 검증 수행",
                            item2: "트랜잭션에서 무거운 작업 제거:",
                            item2_1: "데이터 마이그레이션",
                            item2_2: "백업 관련 처리"
                        },
                        section2: {
                            title: "2. 배치 기반 후처리",
                            item1: "탈퇴 관련 정리 작업을 처리하는 전용 배치 작업 도입:",
                            item1_1: "비피크 시간대(새벽 04:00–05:00)에 실행",
                            item1_2: "필수 검증 수행",
                            item2: "배치 처리 전략:",
                            item2_1: "status = -1인 사용자만 처리",
                            item2_2: "문제가 있는 레코드에 대한 무한 재시도 방지 안전장치 추가",
                            item2_3: "추적 및 복구를 위한 상세 로깅 보장"
                        }
                    },
                    result: {
                        title: "결과",
                        section1: {
                            title: "성능 개선 (Pinpoint)",
                            item1: "이전: API 응답 시간 ~1250ms",
                            item2: "이후: API 응답 시간 ~150ms",
                            item3: "트랜잭션 지속 시간 대폭 감소"
                        },
                        section2: {
                            title: "시스템 영향",
                            item1: "피크 탈퇴 기간 동안 DB CPU 스파이크 감소",
                            item2: "동시 트래픽 상황에서 전반적인 API 안정성 향상",
                            item3: "공유 데이터베이스 리소스에 대한 락 경합 위험 감소",
                            item4: "비필수 무거운 작업 처리를 위한 확장 가능한 패턴 확립"
                        }
                    }
                }
            }
        };

        // Get translation by path
        function getPageTranslation(path) {
            const lang = getCurrentLanguage();
            const keys = path.split('.');
            let value = pageTranslations[lang];

            for (const key of keys) {
                if (value && typeof value === 'object') {
                    value = value[key];
                } else {
                    return null;
                }
            }

            return value;
        }

        // Update all translatable content
        function updatePageContent() {
            const lang = getCurrentLanguage();

            // Update title
            document.title = getPageTranslation('page.title') || document.title;

            // Update elements with data-i18n
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                const translation = getPageTranslation(key);
                if (translation) {
                    element.textContent = translation;
                }
            });

            // Update elements with data-i18n-html
            document.querySelectorAll('[data-i18n-html]').forEach(element => {
                const key = element.getAttribute('data-i18n-html');
                const translation = getPageTranslation(key);
                if (translation) {
                    element.innerHTML = translation;
                }
            });

            // Update HTML lang attribute
            document.documentElement.lang = lang;
        }

        // Get current language from localStorage
        function getCurrentLanguage() {
            const saved = localStorage.getItem('preferredLanguage');
            return (saved === 'ko' || saved === 'en') ? saved : 'en';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            updatePageContent();

            // Listen for language changes from other pages
            window.addEventListener('storage', function(e) {
                if (e.key === 'preferredLanguage') {
                    updatePageContent();
                }
            });
        });
    </script>
    <script src="script.js"></script>
</body>
</html>
